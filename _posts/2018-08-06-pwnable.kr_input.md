---
title: "pwnable.kr input"
Categories:
    - Pwn
tag:
    - Pwn
    - Writeup
    - Pwnable.kr
---

> Mom? how can I pass my input to a computer program?  
>
> ssh input2@pwnable.kr -p2222 (pw:guest)  

这道题考查了多种输入方式。全体总共分为5个阶段，下面分阶段讲解一下。

<!-- more -->

## 准备工作

我们这个题的思路是通过在服务器上编写一个代码来实现的，但是当前所在目录`/home/input2`是无法满足我们的要求的，所以我们得换一个目录。试验后发现我们可以去`/tmp`目录下创建一个我们私有得目录，我们就在这个私有目录下完成操作。

我们还需执行`ln -s /home/input2/flag flag`来创建一个flag的连接文件。~~原因可以看完文章后再来看，这样好懂一点。~~原因是因为我们是在私有目录下编写程序，程序通过execve来调用input的。这时input里执行的`system("/bin/cat flag");`使用的路径是我们的私有路径，也就是说cat的是我们私有路径下的flag。

## Stage 1-argv

第一个阶段是使用参数进行输入。先看一下源码：

```c
    // argv
    if(argc != 100) return 0;
    if(strcmp(argv['A'],"\x00")) return 0;
    if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0;
    printf("Stage 1 clear!\n");
```

要求如下：

> 要传递100个参数  
> 第'A'个即第65个参数内容是 "\x00"  
> 第'B'个即第66个参数内容是 "\x20\x0a\x0d"  

除了以上要求我们还要注意两点。

> 第0个参数是执行路径  
> argv是一个以NULL结尾的指针数组  

基本思路就是在服务器上编写一个程序，程序调用execve()来启动input程序，同时完成传参工作。

```c
    char *exe_path = "/home/input2/input";

    // Stage 1-argv
    char *argv[101] = {[0 ... 99] = "a", NULL};
    argv[0] = exe_path;
    argv['A'] = "\x00";
    argv['B'] = "\x20\x0a\x0d";
    argv[100] = NULL;

    execve(exe_path, argv, NULL);
```

## Stage 2-stdio

第二阶段考查stdio。看一下源码：

```c
    // stdio
    char buf[4];
    read(0, buf, 4);
    if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0;
    read(2, buf, 4);
    if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0;
    printf("Stage 2 clear!\n");
```

要求是:

> 从stdin输入 "\x00\x0a\x00\xff"  
> 从stderr输入"\x00\x0a\x02\xff"  

这里采用pipe来进行输入。具体来讲就是用fork生成一个子进程，由子进程通过pipe向父进程输入数据，输入进父进程的数据通过dup2重定向到stdin和stderr中去。

```c
    // Stage 2-stdio
    int pipe2stdin[2];
    int pipe2stderr[2];
    pid_t child_pid;

    if(pipe(pipe2stdin) < 0 || pipe(pipe2stderr) < 0){
        perror("pipe failed!\n");
        exit(1);
    }

    if((child_pid = fork()) < 0){
        perror("fork failed!\n");
        exit(1);
    }

    if(child_pid == 0){
        close(pipe2stdin[0]);
        close(pipe2stderr[0]);

        write(pipe2stdin[1],  "\x00\x0a\x00\xff", 4);
        write(pipe2stderr[1], "\x00\x0a\x02\xff", 4);

        close(pipe2stdin[1]);
        close(pipe2stderr[1]);

        exit(0);
    }else{
        close(pipe2stdin[1]);
        close(pipe2stderr[1]);

        dup2(pipe2stdin[0], 0);
        dup2(pipe2stderr[0], 2);

        close(pipe2stdin[0]);
        close(pipe2stderr[0]);

        execve(exe_path, argv, NULL);
        perror("execve failed!\n");
        exit(1);
    }
```

## Stage 3-env

第3阶段考查env的填写，这个其实和argv很像。看一下源码：

```c
    // env
    if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0;
    printf("Stage 3 clear!\n");
```

题目要求就是向程序传递一个名为"\xde\xad\xbe\xef"，值为"\xca\xfe\xba\xbe"的环境变量。

```c
    char *envp[2] = {"\xde\xad\xbe\xef=\xca\xfe\xba\xbe", NULL};

    execve(exe_path, argv, envp);
```

## Stage 4-file

第4阶段是考查的写入文件。看源代码：

```c
    // file
    FILE* fp = fopen("\x0a", "r");
    if(!fp) return 0;
    if( fread(buf, 4, 1, fp)!=1 ) return 0;
    if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0;
    fclose(fp);
    printf("Stage 4 clear!\n");
```

题目要求在运行目录下有一个叫"\x0a"的文件，里面内容是"\x00\x00\x00\x00"。

所以我们创建一个"\x0a"的文件，向里面写入"\x00\x00\x00\x00"就ok了。

```c
    // Stage 4-file
    FILE *fp = fopen("\x0a", "w");
    if(!fp) return 0;
    if( fwrite("\x00\x00\x00\x00", 4, 1, fp) != 1) return 0;
    fclose(fp);
```

## Stage 5-network

最后阶段是考察的网络通信。先看源码：

```c
    // network
    int sd, cd;
    struct sockaddr_in saddr, caddr;
    sd = socket(AF_INET, SOCK_STREAM, 0);
    if(sd == -1){
        printf("socket error, tell admin\n");
        return 0;
    }
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = INADDR_ANY;
    saddr.sin_port = htons( atoi(argv['C']) );
    if(bind(sd, (struct sockaddr*)&saddr, sizeof(saddr)) < 0){
        printf("bind error, use another port\n");
        return 1;
    }
    listen(sd, 1);
    int c = sizeof(struct sockaddr_in);
    cd = accept(sd, (struct sockaddr *)&caddr, (socklen_t*)&c);
    if(cd < 0){
        printf("accept error, tell admin\n");
        return 0;
    }
    if( recv(cd, buf, 4, 0) != 4 ) return 0;
    if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0;
    printf("Stage 5 clear!\n");
```

这段代码虽然比较长但是其实还是比较简单的。就是第'C'个即第67个参数保存着端口号，监听该端口，从该端口中接收到"\xde\xad\xbe\xef"即可。

假设argv['C'] = 7777,那么这里我们借用pipe时fork出的子进程向"127.0.0.1：7777"发送"\xde\xad\xbe\xef"来完成。

```c
    // 在argv处添加一条 argv['C'] = "7777";
    // Stage 5-network
    int sockfd;
    struct sockaddr_in addr;
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0){
        printf("socket error!\n");
        exit(1);
    }
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr.sin_port = htons( atoi(argv['C']) );
    if( connect(sockfd, (struct sockaddr*)(&addr), sizeof(struct sockaddr)) < 0){
        perror("connect error!\n");
        exit(1);
    }
    write(sockfd, "\xde\xad\xbe\xef", 4);
    close(sockfd);
```

## 完整代码

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

int main(){
    char *exe_path = "/home/input2/input";

    // Stage 1-argv
    char *argv[101] = {[0 ... 99] = "a", NULL};
    argv[0] = exe_path;
    argv['A'] = "\x00";
    argv['B'] = "\x20\x0a\x0d";
    argv['C'] = "7777";         // Stage 5-network 中用来保存端口的
    argv[100] = NULL;

    // Stage 3-env
    char *envp[2] = {"\xde\xad\xbe\xef=\xca\xfe\xba\xbe", NULL};

    // Stage 4-file
    FILE *fp = fopen("\x0a", "w");
    if(!fp) return 0;
    if( fwrite("\x00\x00\x00\x00", 4, 1, fp) != 1) return 0;
    fclose(fp);

    // Stage 2-stdio
    int pipe2stdin[2];
    int pipe2stderr[2];
    pid_t child_pid;

    if(pipe(pipe2stdin) < 0 || pipe(pipe2stderr) < 0){
        perror("pipe failed!\n");
        exit(1);
    }

    if((child_pid = fork()) < 0){
        perror("fork failed!\n");
        exit(1);
    }

    if(child_pid == 0){
        close(pipe2stdin[0]);
        close(pipe2stderr[0]);

        write(pipe2stdin[1],  "\x00\x0a\x00\xff", 4);
        write(pipe2stderr[1], "\x00\x0a\x02\xff", 4);

        close(pipe2stdin[1]);
        close(pipe2stderr[1]);

        // Stage 5-network
        sleep(3);
        int sockfd;
        struct sockaddr_in addr;
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if(sockfd < 0){
            printf("socket error!\n");
            exit(1);
        }
        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        addr.sin_port = htons( atoi(argv['C']) );
        if( connect(sockfd, (struct sockaddr*)(&addr), sizeof(struct sockaddr)) < 0){
            perror("connect error!\n");
            exit(1);
        }
        write(sockfd, "\xde\xad\xbe\xef", 4);
        close(sockfd);

        exit(0);
    }else{
        close(pipe2stdin[1]);
        close(pipe2stderr[1]);

        dup2(pipe2stdin[0], 0);
        dup2(pipe2stderr[0], 2);

        close(pipe2stdin[0]);
        close(pipe2stderr[0]);

        execve(exe_path, argv, envp);
        perror("execve failed!\n");
        exit(1);
    }

    return 0;
}
```

flag: Mommy! I learned how to pass various input in Linux :)

## 吐槽

第一个地方是执行目录是`/home/input2`。没错，是input ___2___。后面竟然还有个2。开始一直以为是我代码有问题，结果毛病在这...我是服气的，学到了。

第二个地方是我虽然看不了/tmp下有哪些文件夹but我确实进了其他人的文件夹了...还看了别人的代码学习了一下...

我这是一份c的代码，后面有时间在补一份python的。大家还可以看看p4nda的文章，他/她是用pwntools来实现了一下，文章地址见本文最后。

## 参考资料

+ werew. [Pwnable.kr – input](https://werewblog.wordpress.com/2016/01/11/pwnable-kr-input/)
+ p4nda. [【pwnable.kr】input](https://www.cnblogs.com/p4nda/p/7147572.html)