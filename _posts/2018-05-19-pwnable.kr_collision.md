---
title: "pwnable.kr collision"
Categories:
    - Pwn
tag:
    - Pwn
    - Writeup
    - Pwnable.kr
---

> Daddy told me about cool MD5 hash collision today.  
> I wanna do something like that too!  
>
> ssh col@pwnable.kr -p2222 (pw:guest)  

<!-- more -->

这题直接给了源码的。

```c
#include <stdio.h>
#include <string.h>
unsigned long hashcode = 0x21DD09EC;
unsigned long check_password(const char* p){
    int* ip = (int*)p;
    int i;
    int res=0;
    for(i=0; i<5; i++){
        res += ip[i];
    }
    return res;
}

int main(int argc, char* argv[]){
    if(argc<2){
        printf("usage : %s [passcode]\n", argv[0]);
        return 0;
    }
    if(strlen(argv[1]) != 20){
        printf("passcode length should be 20 bytes\n");
        return 0;
    }

    if(hashcode == check_password( argv[1] )){
        system("/bin/cat flag");
        return 0;
    }
    else
        printf("wrong passcode.\n");
    return 0;
}
```

由下面这段代码可知我们需要传递给程序一个参数，并且参数长度为20字节。

```c
if(argc<2){
    printf("usage : %s [passcode]\n", argv[0]);
    return 0;
}
if(strlen(argv[1]) != 20){
    printf("passcode length should be 20 bytes\n");
    return 0;
}
```

然后程序进入`check_password(char *)`，在`check_password()`中将传进的字符串强转为了int。然后5个整型求和。

最简单的思路是16个`\x00`后加4个字节的`0x21DD09EC`。但是`\x09`是`HTab`,会造成字符串被截断。

我们退而求其次，做一个简单的加法，16个`\x01`后加4个字节的`0x1DD905E8`。

```./col  `python -c "print '\x01'*16 + '\xE8\x05\xD9\x1D'"` ```

flag: `daddy! I just managed to create a hash collision :)`