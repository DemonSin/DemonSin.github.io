---
layout: post
title: "GOT与PLT"
date: 2018-06-16 
description: "Linux"
tag: Linux
---

## 0x00 介绍

在动态链接的情况下，程序模块之间包含了大量的函数引用，在程序加载进内存后，动态链接器会花费大量时间在解决程序模块之间的函数引用的符号查找以及重定位，这必定会极大的影响动态连接的性能。而且我们可以想象到很多时候一个程序从启动到结束有些函数其实我们并不会用到，最通俗的例子你每次打开电脑都会把你操作系统的每一个功能都去用一次吗？你每次写程序都会把你IDE的每一个功能用到？显然这是不可能的。因此开始就链接好所有函数是很不明智的。所以ELF采用了一种叫做延迟绑定 (Lazy Binding) 的技术，也就是函数第一用到的时候再去解决该函数的绑定问题。

下面我们就通过观察下面程序来讲一下延迟绑定技术。

```c
/* test.c
 * gcc -o test test.c
 */

#include <stdio.h>
int main()
{
	int n;
	puts("please input n:");
	scanf("%d", &n);
	printf("n = %d\n", n);
	return 0;
}
```

## 0x01 Procedure Linkage Table 过程链接表

使用 `objdump -d test` 反汇编出 main()代码看看。

![img_0](/images/posts/GOT与PLT/img_0.png)

看图我们发现3个函数调用都是\<func@plt\>。也就是这里的 call都是调用到 PLT表去了。

PLT (procedure Linkage Table, 过程链接表) 其实就是一堆相似的精巧的指令序列。这段指令序列功能就是调用动态链接器来完成该函数的绑定工作。先给出PLT的一段指令再具体讲PLT做了些什么。

```c
func@plt:
jmp *(func@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
```

首先一个jmp跳转到 func@GOT 中所保存地址处。这里你一定迷惑这又是什么，这其实就是 GOT表，后面我们会讲到，这里我们就假设其中保存的地址就是 jmp的下一条指令 `push n` ，具体GOT我们后面再细说。

动态链接器在完成函数的绑定工作时需要知道需要需要绑定函数是那个模块的谁。接下来的两条指令就是告诉动态链接器这些信息然后再用最后一条指令调用动态链接器。没错 _dl_runtime_resolve 就是我们的动态链接器中用来完成地址绑定的函数。

`push n` 压入一个数字n，这个n就是func这个符号引用在重定位表 ".rela.plt" 中的下标。`push moduleID` 就是将函数的模块ID压入栈。

调用完 _dl_runtime_resolve 后 func@GOT 中保存的就是 func 的起始地址了。下一次再调用 func 时就可以直接通过第一条指令到达我们想到的地方了。

我们来看看程序中 PLT 具体长什么样子。

![img_1](/images/posts/GOT与PLT/img_1.png)

怎么和上面讲的不一样?每一段PLT其实就是和上面差不多的4条指令序列，其中最后两条指令基本都是一样的，所以为了减少代码重复就对代码做了一些小小的调整。PLT表以16字节为一项，第1项就装上面的最后两条指令。从第2项开始就是每一个func所对应的前两条指令，然后再通过每项中第3条指令到第1项去。现在再看看图是不是理解一些了。但是第1项里的代码还是有些看不懂?其实就是将 moduleID 和 _dl_runtime_resolve 也放到了GOT 表中，GOT 的详细信息看下面。

## 0x02 Global Offset Table 全局偏移表

GOT表其实就是一个地址表，每一项就是全局变量引用或函数引用的地址信息。在ELF文件中，GOT (Global Offset Table, 全局偏移表) 拆分成了 ".got" 和 ".got.plt" 两个表。".got" 用来保存全局变量应用的地址，".got.plt" 用来保存函数引用的地址。".got" 会在模块加载入内存时就重定位好 和 ".got.plt"

另外，".got.plt"前三项有着特殊的意义，分别装的东西如下：

+ 第一项是".dynamic"段的地址。
+ 第二项是本模块ID，在装载相应共享模块时由动态链接器初始化。
+ 第三项是 _dl_runtime_resolve 地址，同样由动态链接器初始化。

第四项起才开始保存外部函数引用。

使用 `objdump -s test` 来查看两张表,当然这时还没重定向，".rela.plt" 的二、三项和 ".rela.dyn" 都是NULL。

![img_2](/images/posts/GOT与PLT/img_2.png)

两张表对应的重定位表分别是 ".rela.dyn" 和 ".rela.plt" ，可以使用 `readelf -r test` 来查看。

![img_3](/images/posts/GOT与PLT/img_3.png)

## 0x03 参考资料

+ 俞甲子, 石凡, 潘爱民. 程序员的自我修养. 北京: 电子工业出版社
+ PhyzX. [Linux中的GOT和PLT到底是个啥？](http://www.freebuf.com/articles/system/135685.html)
+ 代码疯子. [Linux GOT与PLT](http://www.programlife.net/linux-got-plt.html)